
BREAK                  : 'break'
DEFAULT                : 'default'
FUNC                   : 'func'
INTERFACE              : 'interface'
SELECT                 : 'select'
CASE                   : 'case'
DEFER                  : 'defer'
GO                     : 'go'
MAP                    : 'map'
STRUCT                 : 'struct'
CHAN                   : 'chan'
ELSE                   : 'else'
GOTO                   : 'goto'
PACKAGE                : 'package'
SWITCH                 : 'switch'
CONST                  : 'const'
FALLTHROUGH            : 'fallthrough'
IF                     : 'if'
RANGE                  : 'range'
TYPE                   : 'type'
CONTINUE               : 'continue'
FOR                    : 'for'
IMPORT                 : 'import'
RETURN                 : 'return'
VAR                    : 'var'

NIL_LIT                : 'nil'

IDENTIFIER             : LETTER (LETTER | UNICODE_DIGIT)*

// Punctuation

L_PAREN                : '('
R_PAREN                : ')'
L_CURLY                : '{'
R_CURLY                : '}'
L_BRACKET              : '['
R_BRACKET              : ']'
ASSIGN                 : '='
COMMA                  : ','
SEMI                   : ';'
COLON                  : ':'
DOT                    : '.'
PLUS_PLUS              : '++'
MINUS_MINUS            : '--'
DECLARE_ASSIGN         : ':='
ELLIPSIS               : '...'

// Logical

LOGICAL_OR             : '||'
LOGICAL_AND            : '&&'

// Relation operators

EQUALS                 : '=='
NOT_EQUALS             : '!='
LESS                   : '<'
LESS_OR_EQUALS         : '<='
GREATER                : '>'
GREATER_OR_EQUALS      : '>='

// Arithmetic operators

OR                     : '|'
DIV                    : '/'
MOD                    : '%'
LSHIFT                 : '<<'
RSHIFT                 : '>>'
BIT_CLEAR              : '&^'
UNDERLYING             : '~'

// Unary operators

EXCLAMATION            : '!'

// Mixed operators

PLUS                   : '+'
MINUS                  : '-'
CARET                  : '^'
STAR                   : '*'
AMPERSAND              : '&'
RECEIVE                : '<-'

// Number literals

DECIMAL_LIT            : ('0' | [1-9] ('_'? [0-9])*)
BINARY_LIT             : '0' [bB] ('_'? BIN_DIGIT)+
OCTAL_LIT              : '0' [oO]? ('_'? OCTAL_DIGIT)+
HEX_LIT                : '0' [xX]  ('_'? HEX_DIGIT)+


FLOAT_LIT : (DECIMAL_FLOAT_LIT | HEX_FLOAT_LIT)

DECIMAL_FLOAT_LIT      : DECIMALS ('.' DECIMALS? EXPONENT? | EXPONENT) | '.' DECIMALS EXPONENT?
                       

HEX_FLOAT_LIT          : '0' [xX] HEX_MANTISSA HEX_EXPONENT
                       

HEX_MANTISSA  : ('_'? HEX_DIGIT)+ ('.' ( '_'? HEX_DIGIT )*)? | '.' HEX_DIGIT ('_'? HEX_DIGIT)*

HEX_EXPONENT  : [pP] [+-]? DECIMALS


IMAGINARY_LIT          : (DECIMAL_LIT | BINARY_LIT |  OCTAL_LIT | HEX_LIT | FLOAT_LIT) 'i'

// Rune literals

RUNE               : '\'' (UNICODE_VALUE | BYTE_VALUE) '\''

RUNE_LIT                : RUNE



BYTE_VALUE : OCTAL_BYTE_VALUE | HEX_BYTE_VALUE

OCTAL_BYTE_VALUE: '\\' OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT

HEX_BYTE_VALUE: '\\' 'x'  HEX_DIGIT HEX_DIGIT

LITTLE_U_VALUE: '\\' 'u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT

BIG_U_VALUE: '\\' 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT

// String literals

RAW_STRING_LIT         : '`' ~'`'*                      '`'
INTERPRETED_STRING_LIT : '"' (~["\\] | ESCAPED_VALUE)*  '"'

// Hidden tokens

//WS                     : [ \t]+             
COMMENT                : '/*' .*? '*/'     
TERMINATOR             : [\r\n]+         
LINE_COMMENT           : '//' ~[\r\n]*  

UNICODE_VALUE: ~[\r\n'] | LITTLE_U_VALUE | BIG_U_VALUE | ESCAPED_VALUE

// Fragments

ESCAPED_VALUE    : '\\' ('u' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT | 'U' HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT HEX_DIGIT | [abfnrtv\\'"] | OCTAL_DIGIT OCTAL_DIGIT OCTAL_DIGIT | 'x' HEX_DIGIT HEX_DIGIT)
    

DECIMALS    : [0-9] ('_'? [0-9])*
    

OCTAL_DIGIT    : [0-7]
    

HEX_DIGIT    : [0-9a-fA-F]
    

BIN_DIGIT    : [01]

EXPONENT    : [eE] [+-]? DECIMALS


LETTER    : UNICODE_LETTER | '_'


//[\p{Nd}] matches a digit zero through nine in any script except ideographic scripts
UNICODE_DIGIT    : [\p{Nd}]

//[\p{L}] matches any kind of letter from any language
UNICODE_LETTER    : [\p{L}]





// Ignore any comments that only span one line
COMMENT_NLSEMI                : '/*' ~[\r\n]*? '*/'  
LINE_COMMENT_NLSEMI : '//' ~[\r\n]*   
// Emit an EOS token for any newlines, semicolon, multiline comments or the EOF and 
//return to normal lexing
EOS:              ([\r\n]+ | ';' | '/*' .*? '*/' | EOF)   

sourceFile =
	packageClause eos (importDecl eos)* (
		(functionDecl | methodDecl | declaration) eos
	)* EOF

packageClause = PACKAGE IDENTIFIER

importDecl =
	IMPORT (importSpec | L_PAREN (importSpec eos)* R_PAREN)

importSpec = (DOT | IDENTIFIER)? importPath

importPath = string_

declaration = constDecl | typeDecl | varDecl

constDecl = CONST (constSpec | L_PAREN (constSpec eos)* R_PAREN)

constSpec = identifierList (type_? ASSIGN expressionList)?

identifierList = IDENTIFIER (COMMA IDENTIFIER)*

expressionList = expression (COMMA expression)*

typeDecl = TYPE (typeSpec | L_PAREN (typeSpec eos)* R_PAREN)

typeSpec = aliasDecl | typeDef

aliasDecl  = IDENTIFIER ASSIGN type_

typeDef  = IDENTIFIER typeParameters? type_

typeParameters  = L_BRACKET typeParameterDecl (COMMA typeParameterDecl)* R_BRACKET

typeParameterDecl  = identifierList typeElement

typeElement  = typeTerm (OR typeTerm)*

typeTerm  = UNDERLYING? type_

// Function declarations

functionDecl = FUNC IDENTIFIER typeParameters? signature block?

methodDecl = FUNC receiver IDENTIFIER signature block?

receiver = parameters

varDecl = VAR (varSpec | L_PAREN (varSpec eos)* R_PAREN)

varSpec =
	identifierList (
		type_ (ASSIGN expressionList)?
		| ASSIGN expressionList
	)

block = L_CURLY statementList? R_CURLY

statementList = ((SEMI | EOS )? statement eos)+

statement =
	declaration
	| labeledStmt
	| simpleStmt
	| goStmt
	| returnStmt
	| breakStmt
	| continueStmt
	| gotoStmt
	| fallthroughStmt
	| block
	| ifStmt
	| switchStmt
	| selectStmt
	| forStmt
	| deferStmt

simpleStmt =
	sendStmt
	| incDecStmt
	| assignment
	| expressionStmt
	| shortVarDecl

expressionStmt = expression

sendStmt =  expression RECEIVE expression

incDecStmt = expression (PLUS_PLUS | MINUS_MINUS)

assignment = expressionList assign_op expressionList

assign_op = (
		PLUS
		| MINUS
		| OR
		| CARET
		| STAR
		| DIV
		| MOD
		| LSHIFT
		| RSHIFT
		| AMPERSAND
		| BIT_CLEAR
	)? ASSIGN

shortVarDecl = identifierList DECLARE_ASSIGN expressionList

labeledStmt = IDENTIFIER COLON statement?

returnStmt = RETURN expressionList?

breakStmt = BREAK IDENTIFIER?

continueStmt = CONTINUE IDENTIFIER?

gotoStmt = GOTO IDENTIFIER

fallthroughStmt = FALLTHROUGH

deferStmt = DEFER expression

ifStmt =
	IF ( expression
			| eos expression
			| simpleStmt eos expression
			) block (
		ELSE (ifStmt | block)
	)?

switchStmt = exprSwitchStmt | typeSwitchStmt

exprSwitchStmt =
	SWITCH (expression?
					| simpleStmt? eos expression?
					) L_CURLY exprCaseClause* R_CURLY

exprCaseClause = exprSwitchCase COLON statementList?

exprSwitchCase = CASE expressionList | DEFAULT

typeSwitchStmt =
	SWITCH ( typeSwitchGuard
					| eos typeSwitchGuard
					| simpleStmt eos typeSwitchGuard)
					 L_CURLY typeCaseClause* R_CURLY

typeSwitchGuard = (IDENTIFIER DECLARE_ASSIGN)? primaryExpr DOT L_PAREN TYPE R_PAREN

typeCaseClause = typeSwitchCase COLON statementList?

typeSwitchCase = CASE typeList | DEFAULT

typeList = (type_ | NIL_LIT) (COMMA (type_ | NIL_LIT))*

selectStmt = SELECT L_CURLY commClause* R_CURLY

commClause = commCase COLON statementList?

commCase = CASE (sendStmt | recvStmt) | DEFAULT

recvStmt = (expressionList ASSIGN | identifierList DECLARE_ASSIGN)? expression

forStmt = FOR (expression? | forClause | rangeClause?) block

forClause =
	 simpleStmt? eos expression? eos simpleStmt?

rangeClause = (
		expressionList ASSIGN
		| identifierList DECLARE_ASSIGN
	)? RANGE expression

goStmt = GO expression

type_ = typeName typeArgs? | typeLit | L_PAREN type_ R_PAREN

typeArgs = L_BRACKET typeList COMMA? R_BRACKET

typeName = qualifiedIdent | IDENTIFIER

typeLit =
	arrayType
	| structType
	| pointerType
	| functionType
	| interfaceType
	| sliceType
	| mapType
	| channelType

arrayType = L_BRACKET arrayLength R_BRACKET elementType

arrayLength = expression

elementType = type_

pointerType = STAR type_

interfaceType =
	INTERFACE L_CURLY ((methodSpec | typeElement ) eos)* R_CURLY

sliceType = L_BRACKET R_BRACKET elementType

// It's possible to replace `type` with more restricted typeLit list and also pay attention to nil maps
mapType = MAP L_BRACKET type_ R_BRACKET elementType

channelType = (CHAN | CHAN RECEIVE | RECEIVE CHAN) elementType

methodSpec =
	IDENTIFIER parameters result
	| IDENTIFIER parameters

functionType = FUNC signature

signature =
	parameters result?

result = parameters | type_

parameters =
	L_PAREN (parameterDecl (COMMA parameterDecl)* COMMA?)? R_PAREN

parameterDecl = identifierList? ELLIPSIS? type_

expression =
	primaryExpr
	|  (
		PLUS
		| MINUS
		| EXCLAMATION
		| CARET
		| STAR
		| AMPERSAND
		| RECEIVE
	) expression
	| expression (
		STAR
		| DIV
		| MOD
		| LSHIFT
		| RSHIFT
		| AMPERSAND
		| BIT_CLEAR
	) expression
	| expression  (PLUS | MINUS | OR | CARET) expression
	| expression (
		EQUALS
		| NOT_EQUALS
		| LESS
		| LESS_OR_EQUALS
		| GREATER
		| GREATER_OR_EQUALS
	) expression
	| expression LOGICAL_AND expression
	| expression LOGICAL_OR expression

primaryExpr =
	operand
	| conversion
	| methodExpr
	| primaryExpr (
		DOT IDENTIFIER
		| index
		| slice_
		| typeAssertion
		| arguments
	)


conversion = type_ L_PAREN expression COMMA? R_PAREN

//operand = literal | operandName typeArgs? | L_PAREN expression R_PAREN
operand = literal | typeName typeArgs? | L_PAREN expression R_PAREN

literal = basicLit | compositeLit | functionLit

basicLit =
	NIL_LIT
	| integer
	| string_
	| FLOAT_LIT

integer =
	DECIMAL_LIT
	| BINARY_LIT
	| OCTAL_LIT
	| HEX_LIT
	| IMAGINARY_LIT
	| RUNE_LIT

operandName = IDENTIFIER

qualifiedIdent = IDENTIFIER DOT IDENTIFIER

compositeLit = literalType literalValue

literalType =
	structType
	| arrayType
	| L_BRACKET ELLIPSIS R_BRACKET elementType
	| sliceType
	| mapType
	| typeName typeArgs?

literalValue = L_CURLY (elementList COMMA?)? R_CURLY

elementList = keyedElement (COMMA keyedElement)*

keyedElement = (key COLON)? element

key = expression | literalValue

element = expression | literalValue

structType = STRUCT L_CURLY (fieldDecl eos)* R_CURLY

fieldDecl = (
		identifierList type_
		| embeddedField
	) string_?

string_ = RAW_STRING_LIT | INTERPRETED_STRING_LIT

embeddedField = STAR? typeName typeArgs?

functionLit = FUNC signature block // function

index = L_BRACKET expression R_BRACKET

slice_ =
	L_BRACKET (
		expression? COLON expression?
		| expression? COLON expression COLON expression
	) R_BRACKET

typeAssertion = DOT L_PAREN type_ R_PAREN

arguments =
	L_PAREN (
		(expressionList | type_ (COMMA expressionList)?) ELLIPSIS? COMMA?
	)? R_PAREN

methodExpr = type_ DOT IDENTIFIER

eos =
	SEMI
	| EOF
	| EOS
	
anything = Any

%%

%parsing {
	recovery anything 
	fragment STRING_INT_CODE
	start sourceFile
	skip COMMENT
}

%nodes {
	ghost
	leaf 
}

%customblock {
	start("//+")
	end("//@")
	basetoken COMMENT
}
