DIRECTIVE	: '#' ~[\n\r]*

COMMENT		: COMMENT_L|COMMENT_ML
COMMENT_L	: '#' ~[\n\r]*
COMMENT_ML	: '"""' .*? '"""'

ITALIC_QUOTE : '`' .*? '`'

QUOTE		: '"'
SPREAD 		: '...'

STRING		: '"' (~["]|'""')* '"'

ID			: [_a-zA-Z\u0430-\u044F\u0410-\u042F\u0192\u06F0\u03A9][_0-9a-zA-Z\u0430-\u044F\u0410-\u042F.\u0192\u06F0\u03A9]*


LB			: '('
RB			: ')'
LSB			: '['
RSB			: ']'
EXM			: '!'
 
CURVE_BRACKETED : %left '{' %right '}'
ROUND_BRACKETED : %left '(' %right ')'
SQUARE_BRACKETED : %left ('['|GENERAL_ATTRIBUTE_START) %right ']'

HEX 		: '0x'[0-9a-fA-F]+
DEC			: '-'?[0-9]+

COMMA 		: ','
COLON		: ':'



content = entity*

entity	= water_entity | type_def | enum_def  | schema_def | scalar_def | union_def | directive_def

directive_def = 'directive' tag* 'repeatable'? 'on' combine_types

schema_def = extend 'schema' tag* '{' type_line* '}'

scalar_def = extend 'scalar' id tag*

union_def = extend 'union' id tag* ('=' combine_types)?
combine_types = id | (id ('|' | '&') combine_types)

enum_def = extend 'enum' id tag* ('{' enum_line* '}')?
enum_line = id tag* ','?

type_def =  extend ('type'|'input'|'interface') id ('implements' combine_types)? tag* ('{' (type_line|func_line)* '}')?
type_line = id COLON type default_value? tag* ','? 
type = id '!'? | '[' type? ']' '!'?

value = id | DEC | STRING | '[' value? ']' | '{' (id COLON value ','?)* '}'
default_value = '=' value

func_line = id '(' func_arg* ')' COLON type tag* ','? 
func_arg = type_line

tag = '@' id ('(' Any ')')? ','?


id = ID | 'type' | 'input' | 'interface' | 'schema' | 'enum' // to allow considering keywords as a var name 


extend = 'extend'?

water_entity	=	Any 'PANIC' 


%%

%parsing {
	recovery entity 
	fragment STRING_INT_CODE
	start content
	skip COMMENT DIRECTIVE STRING
}

%nodes {
	ghost entity
	leaf 
	void LB RB COMMA COLON tag extend directive_def
}

%customblock {
	start("//+")
	end("//@")
	basetoken COMMENT
}

%markup {
	land func_line type_def
	headercore(id) func_line type_def
}
