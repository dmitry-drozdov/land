COMMENT		: COMMENT_L|COMMENT_ML
COMMENT_L	: '//' ~[\n\r]*
COMMENT_ML	: '/*' .*? '*/'

ITALIC_QUOTE : '`' .*? '`'

QUOTE		: '"'
SPREAD 		: '...'

// важно пропускать строки и символы, так как в них могут быть [{(, что нарушит парность скобок

STRING		: STRING_STD
STRING_STD	: '"' ('\\"'|'\\\\'|.)*? '"'

CHAR		: '\'' ('\\\''|'\\\\'|.)*? '\''

// не распознавать анонимные функции, var (...) и return (1+2) как вызовы 
WATER_KEYWORD: 'var' | 'return' | 'func' | '[]byte'


// id не должен оканчиваться на точку, иначе это будет каст x.(type)
ID			: '@'?[_a-zA-Z.\u0391-\u03A9\u03B1-\u03C9][_0-9a-zA-Z.\u0391-\u03A9\u03B1-\u03C9]*[_0-9a-zA-Z\u0391-\u03A9\u03B1-\u03C9] | '@'?[_a-zA-Z\u0391-\u03A9\u03B1-\u03C9]


 
//CURVE_BRACKETED : %left '{' %right '}'
//ROUND_BRACKETED : %left '(' %right ')'
//SQUARE_BRACKETED : %left ('['|GENERAL_ATTRIBUTE_START) %right ']'

NL			: '\n'

content	= entity*
entity	= control | water_entity | block

control = call | if  | for | switch | select 

if = 'if' (call | Any)* block ('else' (block | if))? // else должен быть в одной связке с if, как и в Go
for = 'for' (call | Any)* block

block = '{' (control | block | Any)* '}'

call = ID '(' (anon_func | call | block | Any)*  ')'

water_entity	=	Any

switch = 'switch' (call | Any)* block
select = 'select' block

anon_func = 'func' '(' Any ')' Any block?


// в секции recovery ничего не должно быть, чтобы мы могли восстанавливаться из любого места

%%

%parsing {
	recovery
	fragment STRING_INT_CODE
	start content
	skip COMMENT NL STRING CHAR
}

%nodes {
	ghost entity 
	leaf 
	void
}

%customblock {
	start("//+")
	end("//@")
	basetoken COMMENT
}

%markup {
	land func
	headercore(f_name) func
}
